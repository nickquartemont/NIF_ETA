#!/usr/bin/python
#######################################################################################################
#
# Module : FP_Utilities.py
# Contains : Routines to calculate fission product distributions and save the output
# Author : James Bevins
# Last Modified: 8Jul16
# 
# Later modified by Nick Quartemont 
# Added flux uncertainty 
# Changed some tools 
# Removed GEF and Spline (GEF was done previously)
#######################################################################################################

import os
import openpyxl
import numpy as np
from math import sqrt, exp
from collections import defaultdict
from scipy.optimize import curve_fit
from scipy import interpolate

#---------------------------------------------------------------------------------------#  
def Read_Fission_Spectrum(fname):
    """
    Read in the fission spectrum from a file based on path to csv containing 
    the energy dependent flux. 
    Format (E_upper, Fissions, Relative Error)

    Returns
    - fiss : array of floats - The fission spectrum results
    - e_bins : array of floats - upper energy fission
    - err- relative error for each bin. 
    """

    # Read fission spectrum information
    try: 
        ifile = np.loadtxt(fname,delimiter=",") 
    
    except IOError as e:
        print "I/O error({0}): {1}".format(e.errno, e.strerror)
        print "File not found was: {0}".format(fname)
    e_bins=ifile[:,0]
    fiss=ifile[:,1]
    err=ifile[:,2]
    fiss=fiss/np.sum(fiss)  #normalize

    return e_bins,fiss,err

#---------------------------------------------------------------------------------------# 
def Read_E_Bins(fname):
    """
    Read in the bin structure from a file
    
    Parameters
    ==========
    fname : string
        Path and name to the fission spectrum input file

    Returns
    =======
    bins : list of floats
        The mid-point bin energies
    """
    
    try: 
        ifile = np.loadtxt(fname,delimiter=",",skiprows=1) 
    
    except IOError as e:
        print "I/O error({0}): {1}".format(e.errno, e.strerror)
        print "File not found was: {0}".format(fname)
    lower=ifile[:,0]
    upper=ifile[:,1]
    bins=ifile[:,2]
    return lower,upper,bins

#---------------------------------------------------------------------------------------# 
def Read_FPs(fname):
    """
    Read in the fission product file generated by writeout routine
    
    Parameters
    ==========
    fname : string
        Path and name to the fission spectrum input file

    Optional
    ========
    NONE
    
    Returns
    =======
    fps : list of floats
        The fission product estimates
    """
    
    fps=[]
    err=[]

    try: 
        ifile = open(fname, 'r') 

        # Store the FPs 
        fps=[]
        for line in ifile:
            split_list=line.split(',')
            fps.append(float(split_list[1].strip()))
            err.append(float(split_list[2].strip()))

        # Close the file
        ifile.close()
    except IOError as e:
        print "I/O error({0}): {1}".format(e.errno, e.strerror)
        print "File not found was: {0}".format(fname)
        
    return fps,err

#---------------------------------------------------------------------------------------# 
def Nagy(e, y, b):
    return y * np.exp(b * e)

def montecarlo_error_propogation(func, params, paramsErr, x, multivariate=False):
    if multivariate:
        sampledParams = np.random.multivariate_normal(params, paramsErr, 1000)
    else: 
        sampledParams = np.random.normal(params, paramsErr, (1000,len(params)))
    y=[]
    for p in sampledParams:
        y.append(func(x, *p))
    return np.mean(y), np.std(y) 

#---------------------------------------------------------------------------------------# 
def Build_Linear_Weighted_FPs(fname,e_bins,ff,weight,fis_err):    
    """
    Builds a fission product estimate using a weighted sum from exp data. 
    
    Parameters
    ==========
    fname : string
        Path and name to the fission spectrum input file
    e_bins : list of floats
        Mid-point energies at which to calculate fission product production
    ff : float
        Fission fraction - fraction of the fissions for a given isotope        
    weight : list of floats
        A normalized fission spectrum distribution
    fis_err : list of floats 
        Relative error of fission spectrum distribution 
        
    Returns
    =======
    lin_data : dictionary of lists
        A dictionary of lists for each A.  The list contains the weighted fission fragment production estimate for each energy.
    """
    
    y={}
    err={}
    
    wb = openpyxl.load_workbook(fname)
    
    for tab in wb.get_sheet_names():
        # Import sheet object
        sheet = wb.get_sheet_by_name(tab)

        # Save isotope information
        split_sheet=sheet.title.split('_')
        A=int(split_sheet[1])
        Z=int(split_sheet[0])
        elem=split_sheet[2]
        #print A,Z,elem
        
        # Read in experimental data
        i=1
        exp_data=[]       # [E,y,err,reference]
        while sheet.cell(row=i, column=1).value != None:
            exp_data.append([sheet.cell(row=i, column=1).value, sheet.cell(row=i, column=2).value, \
                             sheet.cell(row=i, column=3).value,sheet.cell(row=i, column=4).value])
            i+=1
        exp_data=sorted(exp_data,key=lambda l:l[0])
        exp_data_e=np.asarray(exp_data)[:,0].astype(np.float)
        exp_data_y=np.asarray(exp_data)[:,1].astype(np.float)*100
        exp_data_err=np.asarray(exp_data)[:,2].astype(np.float)*100
        
        # Calculate Nagy data
        for i in range(0,len(e_bins)):
            if not A in y.keys():
                y[A] = 0
                err[A] = 0
            y[A] += exp_data_y[i]*ff*weight[i]
            err[A] += (exp_data_err[i]**2*ff*weight[i]+(weight[i]*fis_err[i])**2)
    
    for A in y.keys():
        err[A]=sqrt(err[A])       
    return y, err

#---------------------------------------------------------------------------------------# 
def Build_Nagy_Weighted_FPs(fname,e_bins,ff,weight,fis_err):    
    """
    Builds a fission product estimate using Nagy's fits. 
    
    Parameters
    ==========
    fname : string
        Path and name to the fission spectrum input file
    e_bins : list of floats
        Mid-point energies at which to calculate fission product production
    ff : float
        Fission fraction - fraction of the fissions for a given isotope        
    weight : list of floats
        A normalized fission spectrum distribution
    fis_err : list of floats 
        Relative error of fission spectrum distribution 
    
    Returns
    =======
    nagy_data : dictionary of lists
        A dictionary of lists for each A.  The list contains the weighted fission fragment production estimate for each energy.
    """
    
    y={}
    err={}
    b_vals=np.ndarray((0,3))   # Fitting parameter values 
    Yo_vals=np.ndarray((0,3))

    wb = openpyxl.load_workbook(fname)
    
    for tab in wb.get_sheet_names():
        # Import sheet object
        sheet = wb.get_sheet_by_name(tab)

        # Save isotope information
        split_sheet=sheet.title.split('_')
        A=int(split_sheet[1])
        Z=int(split_sheet[0])
        elem=split_sheet[2]
        #print A,Z,elem
        
        # Read in experimental data
        i=1
        exp_data=[]       # [E,y,err,reference]
        while sheet.cell(row=i, column=1).value != None:
            exp_data.append([sheet.cell(row=i, column=1).value, sheet.cell(row=i, column=2).value, \
                             sheet.cell(row=i, column=3).value,sheet.cell(row=i, column=4).value])
            i+=1
        exp_data=sorted(exp_data,key=lambda l:l[0])
        exp_data_e=np.asarray(exp_data)[:,0].astype(np.float)
        exp_data_y=np.asarray(exp_data)[:,1].astype(np.float)*100
        exp_data_err=np.asarray(exp_data)[:,2].astype(np.float)*100

        # Determine fitting parameters
        if A<=106 or A>=131:
            params1,covar1=curve_fit(Nagy, exp_data_e, exp_data_y,sigma=exp_data_err,absolute_sigma=True)
            params2=params1
            perr1 = np.sqrt(np.diag(covar1))
            perr2 = perr1
        else:
            ind=0
            while exp_data_e[ind]<=5.5:
                ind+=1
            params1,covar1=curve_fit(Nagy, exp_data_e[0:ind], exp_data_y[0:ind],sigma=exp_data_err[0:ind],absolute_sigma=True)
            params2,covar2=curve_fit(Nagy, exp_data_e[ind:], exp_data_y[ind:],sigma=exp_data_err[ind:],absolute_sigma=True)
            perr1 = np.sqrt(np.diag(covar1))
            perr2 = np.sqrt(np.diag(covar2))
        # Store fitting data 
        b_vals=np.append(b_vals,np.matrix([A,params1[1],perr2[1]]),axis=0)
        Yo_vals=np.append(Yo_vals,np.matrix([A,params1[0],perr2[0]]),axis=0)

        # Calculate Nagy data
        for i in range(0,len(e_bins)):
            if not A in y.keys():
                y[A] = 0
                err[A] = 0
            if e_bins[i]<=5.5:
                y[A] += Nagy(e_bins[i], *params1)*ff*weight[i]
                err[A] += (montecarlo_error_propogation(Nagy, params1, perr1, e_bins[i], False)[1]\
                                    /Nagy(e_bins[i], *params1))**2*ff*weight[i]
            else: 
                y[A] += (params2[0]*exp(params2[1]*e_bins[i]))*ff*weight[i]
                err[A] += ((montecarlo_error_propogation(Nagy, params2, perr2, e_bins[i], False)[1]\
                                    /Nagy(e_bins[i], *params1))**2*ff*weight[i] +(weight[i]*fis_err[i])**2)
    
    for A in y.keys():
        err[A]=sqrt(err[A])       
    return y, err, Yo_vals,b_vals

#---------------------------------------------------------------------------------------# 
def writeout(outfn,outl):  
    """
    Writes Y(A) to a csv file
    
    Parameters
    ==========
    outfn : string
        Path and name to the output file
    outl : list
        Contains the A, Y, and error data to be output

    Optional
    ========
    None
    
    Returns
    =======
    None
    """
    ofile = open(outfn,"w")

    for out in outl:
        if len(out)==3:
            ofile.write(str(out[0])
                        + "," + str(out[1])
                        + "," + str(out[2])
                        + "\n")
        if len(out)==4:
            ofile.write(str(out[0])
                        + "," + str(out[1])
                        + "," + str(out[2])
                        + "," + str(out[3])
                        + "\n")

    ofile.close()