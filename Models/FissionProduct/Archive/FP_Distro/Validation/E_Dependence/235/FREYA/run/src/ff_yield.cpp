#define iterations 1000000
     #define maxA 200
     #define maxN 30       /* The maximum number of ejectiles per fission generated by FREYA */
     
     #include <stdio.h>
     #include <math.h>
     #include "fissionEvent.h"
     
     extern "C" {
        extern int msfreya_setup_();
        extern int msfreya_event_(int,float,float,float*,int*,int*,float*,int*,int*,float*,int*,float*,int*);
        extern int msfreya_getniso_(int *,int *);
        extern int msfreya_getzas_(int *,int *);
        extern float msfreya_sepn_cvt_(int, int, int);
        extern float msfreya_gsmassn_(int, int);
        extern int msfreya_geterrors_(char *, int *);
        extern int msfreya_reseterrorflag_();
        extern bool msfreya_errorflagset_();
     }
     
     void init(void);
     void initFREYA(int& nisosf, int& nisoif, int& niso,
                    int** ZAs, int** fistypes);
     bool FREYA_event(double ePart, int iso, int fissiontype,
                      int*& ZAs, int*& fistypes, int niso,
                      float* tke_dist, int* n_events, int* ff_dist);
     FILE* openfile(char* name);
     void output(float* tke_dist, int* n_events, int* ff_dist);
     
     int main() {
        double energy_MeV = 10;
        int isotope = 92235;
        int fissiontype = 1;
     
        int nisosf = 0; // Number of spontaneous fission isotopes
        int nisoif = 0; // Number of induced fission isotopes
        int niso = 0;   // Number of fission isotopes
     
        int** ZAs;      // ZAs of fission isotopes
        int** fistypes; // types of fission [spontaneous (0), induced (1)
        ZAs = new int*;
        fistypes = new int*;
     
        int maxerrorlength=10000;
        char errors[maxerrorlength];
     
        float tke_dist[maxA+1];
        int n_events[maxA+1];
        int ff_dist[maxA+1];
        for (int i=0; i<maxA+1; i++) {
           tke_dist[i] = 0.;
           n_events[i] = 0.;
           ff_dist[i] = 0.;
        }
     
        init();
       initFREYA(nisosf, nisoif, niso, ZAs, fistypes);
       niso=nisosf+nisoif;
       
       for (int i=0; i<iterations; i++) {
          if (!FREYA_event(energy_MeV, isotope, fissiontype, 
                           *ZAs, *fistypes, niso,
                           tke_dist, n_events, ff_dist)) {
             int errorlength=maxerrorlength;
             msfreya_geterrors_(&errors[0], &errorlength);
             if (errorlength>1) {
                printf("%s\n",errors);
                exit(1);
             }
          }
       }
       output(tke_dist, n_events, ff_dist);
    }
    
    FILE* openfile(char* name) {
       FILE* fp = fopen(name, "w");
       if (fp == (FILE *) 0) fprintf(stderr, "Could not open %s for writing\n", name);
       return fp;
    }
    
    void init(void) {
       unsigned short int s[3] = {1234, 5678, 9012};
       int i;
       seed48(s);
       return;
    }
    
    void initFREYA(int& nisosf, int& nisoif, int& niso,
                   int** ZAs, int** fistypes) {
    
       int maxerrorlength=10000;
       char errors[maxerrorlength];
    
       msfreya_reseterrorflag_();
       msfreya_setup_();
       if (msfreya_errorflagset_()) {
          int errorlength=maxerrorlength;
          msfreya_geterrors_(&errors[0], &errorlength);
          if (errorlength>1) {
             printf("%s\n",errors);
             exit(1);
          }
       }
       msfreya_getniso_(&nisosf, &nisoif);
       niso=nisosf+nisoif;
    
       // allocate memory to store ZAs for spontaneous and neutron-induced
       // fissions
       *ZAs = new int [niso];
       *fistypes = new int [niso];
    
       // Populate ZAs and fistypes
       msfreya_getzas_(&(*ZAs[0]),&(*fistypes[0]));
    }
    
    bool FREYA_event(double ePart, int iso, int fissiontype,
                     int*& ZAs, int*& fistypes, int niso,
                     float* tke_dist, int* n_events, int* ff_dist
                    ) {
       // if the compound nucleus is ZA, the original nucleus was
       //   ZA for photofission
       //   Z(A-1) for neutron-induced fission
       // treat photofission as if it were neutron-induced fission
       if (fissiontype==2) iso--;
       
       // Find the index of the fission/isotope
       bool foundfission=false;
       int iKm1=0;
       for (iKm1=0; iKm1<niso; iKm1++)
          if (iso == ZAs[iKm1] && ((fissiontype==0) == (fistypes[iKm1]==0))) {
             foundfission=true;
             break;
          }
       if (!foundfission) {
          fprintf(stderr, "ABORT: fission type %d not supported for isotope %d\n", fissiontype, iso);
          exit(1);
       }
    
       int iK=iKm1+1; // FORTRAN indexing
       int Z=iso/1000;
       int freyaA=iso-1000*Z;
       // watch out! in freya, the A for induced fission is the A of the 
       // compound nucleus (for induced fission, add 1 neutron to the nucleus)
       freyaA+=(fissiontype==0)?0:1;
       msfreya_reseterrorflag_();
    
       // Compute nucleus excitation energy for this event
       float eps0;
       float En;
       switch (fissiontype) {
          case 0:
             // spontaneous fission
             eps0 = 0.;
             En=0.;
             break;
          case 1:
             // neutron-induced fission
          case 2:
             // photon-induced fission
             float sepni;
             sepni = msfreya_sepn_cvt_(iK,Z,freyaA);
             if (msfreya_errorflagset_()) return false;
    
             if (fissiontype==1) {
                // neutron-induced fission
                eps0 = sepni+ePart;
                En=ePart;
             } else if (fissiontype==2) {
                // photon-induced fission
                eps0 = ePart;
                En=ePart-sepni;
                if (En<0) En=0.;
             }
             break;
          default:
             fprintf(stderr, "ABORT: fission type %d not supported\n", fissiontype);
             exit(1);
             break;
       }
    
       // ...generate fission event
       // declare those, msfreya_event needs them
       float V0[3]; // velocity of the initial nucleus
       for (int i=0; i<3; i++) V0[i]=0; // nucleus at rest
    
       float P0[5]; // excited energy, momentum and kinetic energy
                    // of nucleus before interaction
       float P1[5]; // excited energy, momentum and kinetic energy
                    // of fission fragment 1
       float P2[5]; // excited energy, momentum and kinetic energy
                    // of fission fragment 2
       int Z1, A1;  // Charge & mass number of fission fragment 1
       int Z2, A2;  // Charge & mass number of fission fragment 2
    
       float W0=msfreya_gsmassn_(Z, freyaA);  // ground-state mass of nucleus
       if (msfreya_errorflagset_()) return false;
       
       P0[0]=W0+eps0;               // Rest energy of init nucleus
       float g0=1.0;                // gamma0
       P0[4]=g0*P0[0];              // Total energy of init nucleus
       for (int i=0; i<3; i++)
          P0[i]=P0[4]*V0[i];        // Momentum of initial nucleus
    
       int mult;                    // Number of particles emitted
       float particles [4*3*maxN];  // their momentum and kinetic energy
       int ptypes [3*maxN];         // their type: 0(g) & 1(n)
       
       msfreya_event_(iK,En,eps0,&(P0[0]),&Z1,&A1,&(P1[0]),&Z2,&A2,&(P2[0]),&mult,&(particles[0]),&(ptypes[0]));
       if (msfreya_errorflagset_()) return false;
    
        // Get total kinetic energy of fission fragments
       float tot_ke = 0;
        tot_ke += P1[4]-P1[0];
        tot_ke += P2[4]-P2[0];
        
        int AL, AH;      // Mass number of light and heavy fission fragments
        
        AL=A1;
        AH=A2;
        if (AL>AH) {
           AL=A2;
           AH=A1;
        }
        n_events[AH]++;
        tke_dist[AH]+= tot_ke;
        ff_dist[AL]++;
        ff_dist[AH]++;
     
        return true;
     }
     
     void output(float* tke_dist, int* n_events, int* ff_dist) {
        char filename [1024];
    
        sprintf(filename, "tke_versus_AH.res");
        FILE* fp = openfile(filename);
        for (int i=0; i<maxA+1; i++) 
           if (n_events[i] != 0)
              fprintf(fp, "%d : %f\n", i, tke_dist[i]/n_events[i]);
        fclose(fp);
     
        sprintf(filename, "ff_yield.res");
        fp = openfile(filename);
        unsigned int sum=0;
        for (int i=0; i<maxA+1; i++) sum += ff_dist[i];
        for (int i=0; i<maxA+1; i++) fprintf(fp, "%d : %f : %f\n", i, 1.*ff_dist[i]/sum, 1.*sqrt(ff_dist[i])/sum);
        fclose(fp);
     
        return;
     }
