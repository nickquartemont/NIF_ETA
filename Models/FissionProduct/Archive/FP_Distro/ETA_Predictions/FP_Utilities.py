#!/usr/bin/python
#######################################################################################################
#
# Module : FP_Utilities.py
#
# Contains : Routines to calculate fission product distributions and save the output
#
# Author : James Bevins
#
# Last Modified: 8Jul16
#
#######################################################################################################

import os
import openpyxl
import numpy as np
from math import sqrt, exp
from collections import defaultdict
from scipy.optimize import curve_fit
from scipy import interpolate

#---------------------------------------------------------------------------------------#  
def Read_Fission_Spectrum(fname):
    """
    Read in the fission spectrum from a file
    
    Parameters
    ==========
    fname : string
        Path and name to the fission spectrum input file

    Optional
    ========
    NONE
    
    Returns
    =======
    fiss : array of floats
        The fission spectrum results
    """
    # Initialize variables
    e_bins=[]
    fiss=[]
    err=[]

    # Read fission spectrum information
    try: 
        ifile = open(fname, 'r') 

        # Store the spectrum
        for line in ifile:
            split_list=line.split(',')
            e_bins.append(float(split_list[0].strip()))
            fiss.append(float(split_list[1].strip()))
            err.append(float(split_list[2].strip()))

        # Close the file
        ifile.close()
    except IOError as e:
        print "I/O error({0}): {1}".format(e.errno, e.strerror)
        print "File not found was: {0}".format(fname)

    np.asarray(fiss)
    fiss=fiss/np.sum(fiss)  #normalize
    
    return e_bins,fiss

#---------------------------------------------------------------------------------------# 
def Read_E_Bins(fname):
    """
    Read in the bin structure from a file
    
    Parameters
    ==========
    fname : string
        Path and name to the fission spectrum input file

    Optional
    ========
    NONE
    
    Returns
    =======
    bins : list of floats
        The mid-point bin energies
    """
    
    lower=[]
    upper=[]
    bins=[]

    try: 
        ifile = open(fname, 'r') 

        # Skip header line
        line=ifile.next()

        # Store the spectrum
        bins=[]
        for line in ifile:
            split_list=line.split(',')
            lower.append(float(split_list[0].strip()))
            upper.append(float(split_list[1].strip()))
            bins.append(float(split_list[2].strip()))

        # Close the file
        ifile.close()
    except IOError as e:
        print "I/O error({0}): {1}".format(e.errno, e.strerror)
        print "File not found was: {0}".format(fname)
        
    return lower,upper,bins

#---------------------------------------------------------------------------------------# 
def Read_FPs(fname):
    """
    Read in the fission product file generated by writeout routine
    
    Parameters
    ==========
    fname : string
        Path and name to the fission spectrum input file

    Optional
    ========
    NONE
    
    Returns
    =======
    fps : list of floats
        The fission product estimates
    """
    
    fps=[]
    err=[]

    try: 
        ifile = open(fname, 'r') 

        # Store the FPs 
        fps=[]
        for line in ifile:
            split_list=line.split(',')
            fps.append(float(split_list[1].strip()))
            err.append(float(split_list[2].strip()))

        # Close the file
        ifile.close()
    except IOError as e:
        print "I/O error({0}): {1}".format(e.errno, e.strerror)
        print "File not found was: {0}".format(fname)
        
    return fps,err

#---------------------------------------------------------------------------------------# 
def Nagy(e, y, b):
    return y * np.exp(b * e)

def montecarlo_error_propogation(func, params, paramsErr, x, multivariate=False):
    if multivariate:
        sampledParams = np.random.multivariate_normal(params, paramsErr, 1000)
    else: 
        sampledParams = np.random.normal(params, paramsErr, (1000,len(params)))
    y=[]
    for p in sampledParams:
        y.append(func(x, *p))
    return np.mean(y), np.std(y) 

#---------------------------------------------------------------------------------------# 
def Build_Linear_Weighted_FPs(fname,e_bins,ff,weight):    
    """
    Builds a fission product estimate using a weighted sum from exp data. 
    
    Parameters
    ==========
    fname : string
        Path and name to the fission spectrum input file
    e_bins : list of floats
        Mid-point energies at which to calculate fission product production
    ff : float
        Fission fraction - fraction of the fissions for a given isotope        
    weight : list of floats
        A normalized fission spectrum distribution

    Optional
    ========
    NONE
    
    Returns
    =======
    lin_data : dictionary of lists
        A dictionary of lists for each A.  The list contains the weighted fission fragment production estimate for each energy.
    """
    
    y={}
    err={}
    
    wb = openpyxl.load_workbook(fname)
    
    for tab in wb.get_sheet_names():
        # Import sheet object
        sheet = wb.get_sheet_by_name(tab)

        # Save isotope information
        split_sheet=sheet.title.split('_')
        A=int(split_sheet[1])
        Z=int(split_sheet[0])
        elem=split_sheet[2]
        #print A,Z,elem
        
        # Read in experimental data
        i=1
        exp_data=[]       # [E,y,err,reference]
        while sheet.cell(row=i, column=1).value != None:
            exp_data.append([sheet.cell(row=i, column=1).value, sheet.cell(row=i, column=2).value, \
                             sheet.cell(row=i, column=3).value,sheet.cell(row=i, column=4).value])
            i+=1
        exp_data=sorted(exp_data,key=lambda l:l[0])
        exp_data_e=np.asarray(exp_data)[:,0].astype(np.float)
        exp_data_y=np.asarray(exp_data)[:,1].astype(np.float)*100
        exp_data_err=np.asarray(exp_data)[:,2].astype(np.float)*100
        
        # Calculate Nagy data
        for i in range(0,len(e_bins)):
            if not A in y.keys():
                y[A] = 0
                err[A] = 0
            y[A] += exp_data_y[i]*ff*weight[i]
            err[A] += exp_data_err[i]**2*ff*weight[i]
    
    for A in y.keys():
        err[A]=sqrt(err[A])       
    return y, err

#---------------------------------------------------------------------------------------# 
def Build_Nagy_Weighted_FPs(fname,e_bins,ff,weight):    
    """
    Builds a fission product estimate using Nagy's fits. 
    
    Parameters
    ==========
    fname : string
        Path and name to the fission spectrum input file
    e_bins : list of floats
        Mid-point energies at which to calculate fission product production
    ff : float
        Fission fraction - fraction of the fissions for a given isotope        
    weight : list of floats
        A normalized fission spectrum distribution

    Optional
    ========
    NONE
    
    Returns
    =======
    nagy_data : dictionary of lists
        A dictionary of lists for each A.  The list contains the weighted fission fragment production estimate for each energy.
    """
    
    y={}
    err={}
    
    wb = openpyxl.load_workbook(fname)
    
    for tab in wb.get_sheet_names():
        # Import sheet object
        sheet = wb.get_sheet_by_name(tab)

        # Save isotope information
        split_sheet=sheet.title.split('_')
        A=int(split_sheet[1])
        Z=int(split_sheet[0])
        elem=split_sheet[2]
        #print A,Z,elem
        
        # Read in experimental data
        i=1
        exp_data=[]       # [E,y,err,reference]
        while sheet.cell(row=i, column=1).value != None:
            exp_data.append([sheet.cell(row=i, column=1).value, sheet.cell(row=i, column=2).value, \
                             sheet.cell(row=i, column=3).value,sheet.cell(row=i, column=4).value])
            i+=1
        exp_data=sorted(exp_data,key=lambda l:l[0])
        exp_data_e=np.asarray(exp_data)[:,0].astype(np.float)
        exp_data_y=np.asarray(exp_data)[:,1].astype(np.float)*100
        exp_data_err=np.asarray(exp_data)[:,2].astype(np.float)*100

        # Determine fitting parameters
        if A<=106 or A>=131:
            params1,covar1=curve_fit(Nagy, exp_data_e, exp_data_y,sigma=exp_data_err,absolute_sigma=True)
            params2=params1
            perr1 = np.sqrt(np.diag(covar1))
            perr2 = perr1
        else:
            ind=0
            while exp_data_e[ind]<=5.5:
                ind+=1
            params1,covar1=curve_fit(Nagy, exp_data_e[0:ind], exp_data_y[0:ind],sigma=exp_data_err[0:ind],absolute_sigma=True)
            params2,covar2=curve_fit(Nagy, exp_data_e[ind:], exp_data_y[ind:],sigma=exp_data_err[ind:],absolute_sigma=True)
            perr1 = np.sqrt(np.diag(covar1))
            perr2 = np.sqrt(np.diag(covar2))
            
        # Calculate Nagy data
        for i in range(0,len(e_bins)):
            if not A in y.keys():
                y[A] = 0
                err[A] = 0
            if e_bins[i]<=5.5:
                y[A] += Nagy(e_bins[i], *params1)*ff*weight[i]
                err[A] += (montecarlo_error_propogation(Nagy, params1, perr1, e_bins[i], False)[1]\
                                    /Nagy(e_bins[i], *params1))**2*ff*weight[i]
            else: 
                y[A] += (params2[0]*exp(params2[1]*e_bins[i]))*ff*weight[i]
                err[A] += (montecarlo_error_propogation(Nagy, params2, perr2, e_bins[i], False)[1]\
                                    /Nagy(e_bins[i], *params1))**2*ff*weight[i]
    
    for A in y.keys():
        err[A]=sqrt(err[A])       
    return y, err

#---------------------------------------------------------------------------------------# 
def Build_Spline_Weighted_FPs(fname,e_bins,ff,weight):   
    """
    Builds a fission product estimate using Spline Interpolation. 
    
    Parameters
    ==========
    fname : string
        Path and name to the fission spectrum input file
    e_bins : list of floats
        Mid-point energies at which to calculate fission product production
    ff : float
        Fission fraction - fraction of the fissions for a given isotope        
    weight : list of floats
        A normalized fission spectrum distribution

    Optional
    ========
    NONE
    
    Returns
    =======
    spline_data : dictionary of lists
        A dictionary of lists for each A.  The list contains the weighted fission fragment production estimate for each energy.
    """
    
    spline_data=defaultdict(list)
    
    wb = openpyxl.load_workbook(fname)
    
    for tab in wb.get_sheet_names():
        # Import sheet object
        sheet = wb.get_sheet_by_name(tab)

        # Save isotope information
        split_sheet=sheet.title.split('_')
        A=int(split_sheet[1])
        Z=int(split_sheet[0])
        elem=split_sheet[2]
        #print A,Z,elem
        
        # Read in experimental data
        i=1
        exp_data=[]       # [E,y,err,reference]
        while sheet.cell(row=i, column=1).value != None:
            exp_data.append([sheet.cell(row=i, column=1).value, sheet.cell(row=i, column=2).value, \
                             sheet.cell(row=i, column=3).value,sheet.cell(row=i, column=4).value])
            i+=1
        exp_data=sorted(exp_data,key=lambda l:l[0])
        exp_data_e=np.asarray(exp_data)[:,0].astype(np.float)
        exp_data_y=np.asarray(exp_data)[:,1].astype(np.float)*100
        exp_data_err=np.asarray(exp_data)[:,2].astype(np.float)*100

        # Calculate Interpolated Data
        spline_data[A].append(interpolate.UnivariateSpline(exp_data_e, exp_data_y, s = 5e8)(e_bins)*ff*weight)
           
    return spline_data

#---------------------------------------------------------------------------------------# 
def Build_GEF_Weighted_FPs(bins,fw,datadir):  
    """
    Builds a fission product estimate using GEF calculations. Must have GEF calculations at 
    each energy point in e_bins.
    
    Parameters
    ==========
    fname : string
        Path and name to the fission spectrum input file
    e_bins : list of floats
        Mid-point energies at which to calculate fission product production
    ff : float
        Fission fraction - fraction of the fissions for a given isotope        
    weight : list of floats
        A normalized fission spectrum distribution

    Optional
    ========
    NONE
    
    Returns
    =======
    gef_data : dictionary of lists
        A dictionary of lists for each A.  The list contains the weighted fission fragment 
        production estimate for each energy.
    """
    one=0
    two=0
    y={}
    err={}
    w=[]
    fy=[]
    
    # Test that weights are normalized
    if sum(fw) != 1:
        print "WARNING: Normailzed weights are not used.  The sum of the weights is {}.".format(sum(fw))

    # Use weighted fission spectra to generate mass yield curves
    for subdir, dirs, files in os.walk(datadir):
        for file in files:
            if file=="GEF.dat":
                #print subdir, file
                weight = 0
                one+=1
                try: 
                    ifile = open(subdir+'/'+file, 'r') 
                    for line in ifile:
                        if line[:7] == ' formed':
                            split_list=line.split(' ')
                            for i in range(0,len(bins)):
                                if bins[i] == float(split_list[8].strip()):
                                    two+=1
                                    weight=fw[i]
                                    #print "Energy =", bins[i]
                                    #print "Fractional weight=",weight
                        if line[:27] =='--- Mass-yield distribution':
                            for i in range(0,6):
                                line=ifile.next()
                            while line[:22] != '        </Mass_yields>':
                                split_list=line.split()
                                if not split_list[0] in y.keys():  # this is the first time we've encountered this mass A
                                # let's initialize our dictionaries
                                    y[split_list[0]] = float(split_list[2])*weight
                                    if float(split_list[2]) > 0:
                                        err[split_list[0]] = ((float(split_list[3])/float(split_list[2]))**2)*weight
                                    else:
                                        err[split_list[0]] = 0
                                else:  # we've encoutered this mass before, no need to initialize, just add to it
                                    y[split_list[0]] += float(split_list[2])*weight
                                    if float(split_list[2]) > 0:
                                        err[split_list[0]] += ((float(split_list[3])/float(split_list[2]))**2)*weight
                                    else:
                                        err[split_list[0]] = 0

                                if int(split_list[0])==160:
                                    w.append(weight)
                                    fy.append(float(split_list[2]))
                                line=ifile.next()
                    # Close the file
                    ifile.close()
                except IOError as e:
                    print "I/O error({0}): {1}".format(e.errno, e.strerror)
                    print "File not found was: {0}".format(fname)

    if one!=two or one!=len(bins):
        print "\n\nWARNING: Not all of the files from {} were imported.\n\n".format(datadir)
        print one, two, len(bins)
        
    for A in y.keys():
        err[A]=sqrt(err[A])
    return y, err

#---------------------------------------------------------------------------------------# 
def writeout(outfn,outl):  
    """
    Writes Y(A) to a csv file
    
    Parameters
    ==========
    outfn : string
        Path and name to the output file
    outl : list
        Contains the A, Y, and error data to be output

    Optional
    ========
    None
    
    Returns
    =======
    None
    """
    ofile = open(outfn,"w")

    for out in outl:
        if len(out)==3:
            ofile.write(str(out[0])
                        + "," + str(out[1])
                        + "," + str(out[2])
                        + "\n")
        if len(out)==4:
            ofile.write(str(out[0])
                        + "," + str(out[1])
                        + "," + str(out[2])
                        + "," + str(out[3])
                        + "\n")

    ofile.close()